{"meta":{"title":"莫守成规","subtitle":"Never abide by rules","description":null,"author":"王龙杰","url":"https://wlongjie.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-05-28T08:35:53.000Z","updated":"2019-05-30T01:52:05.703Z","comments":true,"path":"tags/index.html","permalink":"https://wlongjie.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-05-28T08:24:44.000Z","updated":"2019-05-30T01:54:51.970Z","comments":true,"path":"categories/index.html","permalink":"https://wlongjie.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SAX解析xml文件","slug":"SAX解析xml文件","date":"2019-06-25T03:55:44.157Z","updated":"2019-06-18T01:23:53.575Z","comments":true,"path":"2019/06/25/SAX解析xml文件/","link":"","permalink":"https://wlongjie.github.io/2019/06/25/SAX解析xml文件/","excerpt":"","text":"概述​ SAX，全称Simple API for XML，是一种以事件驱动的XMl API，是XML解析的一种新的替代方法，解析XML常用的还有DOM解析，PULL解析（Android特有），SAX与DOM不同的是它边扫描边解析，自顶向下依次解析，由于边扫描边解析，所以它解析XML具有速度快，占用内存少的优点，对于Android等CPU资源宝贵的移动平台来说是一个巨大的优势。 SAX的优点 解析速度快 占用内存少 SAX的缺点 解析过程中，只知道当前解析的标签的名字和属性 只能解析，不能修改xml文件 无法随机访问某个标签（自上而下一一解析） SAX解析适用场合 对于CPU资源宝贵的设备，如Android等移动设备 对于只需要解析而无需修改的需求 步骤 获取xml文件输入流 获取SAX解析对象工厂 获取SAX解析对象 获取转化规则Handler 加载文件流和转化规则 解析 代码实现xml文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student id=\"1\"&gt; &lt;name&gt;张三1&lt;/name&gt; &lt;age&gt;1&lt;/age&gt; &lt;/student&gt; &lt;student id=\"2\"&gt; &lt;name&gt;张三2&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/student&gt; &lt;student id=\"3\"&gt; &lt;name&gt;张三3&lt;/name&gt; &lt;age&gt;3&lt;/age&gt; &lt;/student&gt; &lt;student id=\"4\"&gt; &lt;name&gt;张三4&lt;/name&gt; &lt;age&gt;4&lt;/age&gt; &lt;/student&gt; &lt;student id=\"5\"&gt; &lt;name&gt;张三5&lt;/name&gt; &lt;age&gt;5&lt;/age&gt; &lt;/student&gt;&lt;/students&gt; 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private int studentId; private String studentName; private int studentAge; public int getStudentId() &#123; return studentId; &#125; public void setStudentId(int studentId) &#123; this.studentId = studentId; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getStudentAge() &#123; return studentAge; &#125; public void setStudentAge(int studentAge) &#123; this.studentAge = studentAge; &#125; @Override public String toString() &#123; return \"Student [studentAge=\" + studentAge + \", studentId=\" + studentId + \", studentName=\" + studentName + \"]\"; &#125; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(int studentId, String studentName, int studentAge) &#123; super(); this.studentId = studentId; this.studentName = studentName; this.studentAge = studentAge; &#125;&#125; 解析规则Handler类 startDocument()：开始读取文档时调用 startElement()：读取开始标签时调用 characters()：读取文本时调用 endElement()：读取结束标签时调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StudentHandle extends DefaultHandler &#123; private List&lt;Student&gt; stuList; private Student student = null; private String temp; public List&lt;Student&gt; getStuList() &#123; return stuList; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; if (\"name\".equals(temp)) &#123; String studentName = new String(ch, start, length); student.setStudentName(studentName); &#125; else if (\"age\".equals(temp)) &#123; String studentAge = new String(ch, start, length); student.setStudentAge(Integer.parseInt(studentAge)); &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (\"student\".equals(qName)) &#123; stuList.add(student); student = null; &#125; temp = null; &#125; @Override public void startDocument() throws SAXException &#123; stuList = new ArrayList&lt;Student&gt;(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (\"student\".equals(qName)) &#123; if (null == student) &#123; student = new Student(); &#125; String studentId = attributes.getValue(\"\", \"id\"); student.setStudentId(Integer.parseInt(studentId)); &#125; else if (\"name\".equals(qName)) &#123; temp = \"name\"; &#125; else if (\"age\".equals(qName)) &#123; temp = \"age\"; &#125; &#125;&#125; 业务类123456789101112131415161718public static List&lt;Student&gt; ReadXml() throws Exception &#123; //获取xml文件输入流 InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"student.xml\"); //获取sax解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); //获取sax解析类 SAXParser saxParser = factory.newSAXParser(); //获取转化规则 StudentHandle studentHandle = new StudentHandle(); //加载文件流和转化规则 saxParser.parse(is, studentHandle); //转化 List&lt;Student&gt; stuList = studentHandle.getStuList(); //返回 return stuList;&#125;","categories":[{"name":"文件操作","slug":"文件操作","permalink":"https://wlongjie.github.io/categories/文件操作/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wlongjie.github.io/tags/Java/"},{"name":"Sax","slug":"Sax","permalink":"https://wlongjie.github.io/tags/Sax/"},{"name":"xml","slug":"xml","permalink":"https://wlongjie.github.io/tags/xml/"}]},{"title":"Maven的简单使用","slug":"Maven的简单使用","date":"2019-06-25T03:55:41.240Z","updated":"2019-06-18T03:01:04.258Z","comments":true,"path":"2019/06/25/Maven的简单使用/","link":"","permalink":"https://wlongjie.github.io/2019/06/25/Maven的简单使用/","excerpt":"","text":"概述 Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。 Maven的作用 Jar包管理 项目构建：对项目进行编译、测试、打包、部署 安装 下载地址：http://maven.apache.org/download.cgi 下载并解压到本地磁盘（目录不能有空格） 配置环境变量（依赖jdk） 配置环境变量 MAVEN_HOME：E:\\Maven\\apache-maven-3.6.0 Path：;%MAVEN_HOME%\\bin 测试：DOS命令：mvn -v eclipse配置Maven Window-&gt;Preferences-&gt;Maven-&gt;Installations 添加Maven根目录：E:\\Maven\\apache-maven-3.6.0\\ 并勾选使用自己安装的Maven Window-&gt;Preferences-&gt;Maven-&gt;User Settings 修改Global Settings：E:\\Maven\\apache-maven-3.6.0\\conf\\settings.xml Idea配置Maven 修改单个项目：File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory：E:\\Maven\\apache-maven-3.6.0\\ 修改User settings file：E:\\Maven\\apache-maven-3.6.0\\conf\\settings.xml 修改 Local repository：D:\\maven\\mavenrep 修改所有新建项目：Others Settings-&gt;Settings for New Projects-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory 修改User settings file：E:\\Maven\\apache-maven-3.6.0\\conf\\settings.xml 修改 Local repository：D:\\maven\\mavenrep Setting.xml文件配置 修改本地仓库位置（本地Jar包存放位置） D:/maven/mavenrep 配置阿里镜像库（提高下载Jar包的速度） 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 我的配置文件（去注释） 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- 本地仓库配置 --&gt; &lt;localRepository&gt;D:/maven/mavenrep&lt;/localRepository&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;!-- 阿里镜像库配置 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt;&lt;/settings&gt;","categories":[{"name":"Jar包管理","slug":"Jar包管理","permalink":"https://wlongjie.github.io/categories/Jar包管理/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wlongjie.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://wlongjie.github.io/tags/Maven/"}]},{"title":"Java实现简单的贪吃蛇","slug":"Java实现简单的贪吃蛇","date":"2019-05-30T08:18:22.581Z","updated":"2019-05-30T08:53:40.939Z","comments":true,"path":"2019/05/30/Java实现简单的贪吃蛇/","link":"","permalink":"https://wlongjie.github.io/2019/05/30/Java实现简单的贪吃蛇/","excerpt":"","text":"源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import java.awt.Color;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.util.ArrayList;import javax.swing.JFrame;import javax.swing.JPanel;public class SnakePanel extends JPanel implements KeyListener, Runnable&#123; private static final long serialVersionUID = 1L; public static Image background; public static Image cellImage; public static Image foolImage; ArrayList&lt;Cell&gt; snakeList = new ArrayList&lt;Cell&gt;(); private Cell food = new Cell(); //方向 public char direction = Direction.RIGHT; public boolean isLive = true; //速度 public int sleep = 100; //横向35个 //纵向35个 public static final int MIN_X = 50 + 2; public static final int MAX_X = MIN_X + 10 * 35 - 10;//350 - 10 + 2 public static final int MIN_Y = 50 - 2; public static final int MAX_Y = MIN_Y + 10 * 35 - 10;//350 - 10 - 2// public static final int edge = 10; public SnakePanel() &#123; background = Toolkit.getDefaultToolkit().createImage(\"bg.png\"); cellImage = Toolkit.getDefaultToolkit().createImage(\"cell.png\"); foolImage = Toolkit.getDefaultToolkit().createImage(\"food.png\"); //初始化蛇 int x = MIN_X; int y = MIN_Y; for (int i = 0; i &lt; 10; i++) &#123; Cell cell = new Cell(x, y); snakeList.add(cell); x += 10; &#125; //初始化食物 getFood(); &#125; //创建食物 public void getFood() &#123; boolean flag; int x, y; do&#123; flag = false; x = (int)(Math.random() * 35) * 10 + 52; y = (int)(Math.random() * 35) * 10 + 48; for (Cell cell : snakeList) &#123; if (cell.getX() == x &amp;&amp; cell.getY() == y) &#123; flag = true; break; &#125; &#125; &#125;while(flag); food.setX(x); food.setY(y); &#125; @Override public void paint(Graphics g) &#123; super.paint(g); g.drawImage(background, 0, 0, this); //g.draw3DRect(50, 50 - 2, 350, 350 - 2, true); //g.draw3DRect(50, 50 - 2, 10, 10, false); for (Cell cell : snakeList) &#123; g.drawImage(cellImage, cell.x , cell.y, this); &#125; g.drawImage(foolImage, food.x , food.y, this); //g.translate(x, y)：将坐标原点移动到(x,y) if (!isLive)&#123; int x = (MIN_X + MAX_X) / 2; int y = (MIN_Y + MAX_Y) / 2; g.setColor(Color.red); g.drawString(\"Game over !!!\", x, y); //死亡信息 &#125; &#125; public static void main(String[] args) &#123; JFrame frame = new JFrame(); frame.setTitle(\"小破蛇\"); frame.setSize(470, 480); frame.setVisible(true); //设置窗口居中显示 frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); SnakePanel sp = new SnakePanel(); frame.add(sp); //frame.setContentPane(new SnakePanel()); //注册事件监听 frame.addKeyListener(sp); //线程 new Thread(sp).start(); &#125; public class Direction &#123; public static final char UP = 'w'; public static final char DOWN = 's'; public static final char LEFT = 'a'; public static final char RIGHT = 'd'; &#125; public class Cell &#123; private int x; private int y; public Cell() &#123; &#125; public Cell(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; &#125; //键盘控制方向 //按下 @Override public void keyPressed(KeyEvent e) &#123; if(e.getKeyCode() == KeyEvent.VK_W || e.getKeyCode() == KeyEvent.VK_UP) &#123; if(direction != Direction.DOWN)direction = Direction.UP; &#125; else if(e.getKeyCode() == KeyEvent.VK_A || e.getKeyCode() == KeyEvent.VK_LEFT) &#123; if(direction != Direction.RIGHT)direction = Direction.LEFT; &#125; else if(e.getKeyCode() == KeyEvent.VK_S || e.getKeyCode() == KeyEvent.VK_DOWN) &#123; if(direction != Direction.UP)direction = Direction.DOWN; &#125; else if(e.getKeyCode() == KeyEvent.VK_D || e.getKeyCode() == KeyEvent.VK_RIGHT) &#123; if(direction != Direction.LEFT)direction = Direction.RIGHT; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; //按下并释放(敲击) @Override public void keyTyped(KeyEvent e) &#123; &#125; //线程：重画 @Override public void run() &#123; while(true) &#123; try &#123; Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int x = snakeList.get(snakeList.size() - 1).x; int y = snakeList.get(snakeList.size() - 1).y; switch(direction) &#123; case Direction.DOWN: y += 10; break; case Direction.LEFT: x -= 10; break; case Direction.RIGHT: x += 10; break; case Direction.UP: y -= 10; break; &#125; //撞墙 if (x &lt; MIN_X || x &gt; MAX_X || y &lt; MIN_Y || y &gt; MAX_Y) &#123; //提示处理 isLive = false; break; &#125; boolean flag = false; for(Cell cell : snakeList) &#123; if (cell.getX() == x &amp;&amp; cell.getY() == y) &#123; flag = true; break; &#125; &#125; //撞自己 if (flag) &#123; //提示处理 isLive = false; break; &#125; //吃食物 if (x == food.x &amp;&amp; y == food.y) &#123; //添加长度 Cell cell = new Cell(x, y); snakeList.add(cell); //重新生成食物 getFood(); &#125; else &#123; //蛇头前进 Cell cell = new Cell(x, y); snakeList.add(cell); //蛇尾前进 snakeList.remove(0); &#125; this.repaint(); &#125; this.repaint(); &#125; &#125; 图片 bg.png:背景 cell:png：一节蛇 food.png:食物 注意 直接运行会报异常，需要三张图片 请根据自己的图片调整蛇的活动区域","categories":[{"name":"Java项目","slug":"Java项目","permalink":"https://wlongjie.github.io/categories/Java项目/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wlongjie.github.io/tags/Java/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"https://wlongjie.github.io/tags/贪吃蛇/"}]},{"title":"Java实现简单的RPC","slug":"Java实现简单的RPC","date":"2019-05-30T08:18:22.577Z","updated":"2019-05-30T08:50:04.535Z","comments":true,"path":"2019/05/30/Java实现简单的RPC/","link":"","permalink":"https://wlongjie.github.io/2019/05/30/Java实现简单的RPC/","excerpt":"","text":"RPC解释 RPC：Remote Procedure Call(远程过程调用) 客户端获取服务端的服务(不同的计算机) RPC所需要的技术 反射技术：客户端给服务端发送代表接口名的字符串，服务端需要通过字符串解析出该字符串代表的接口的一切信息 socket：客户端与服务端交互(传输信息) 动态代理：服务端需要根据客户端的不同请求，返回不同的接口类型，客户端需要接受到不同的接口类型 代码实现 客户端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Client &#123; //获取代表服务端接口的动态代理对象 //serviceName:请求的接口名 //addr:待请求服务端的ip:端口 @SuppressWarnings(\"unchecked\") public static &lt;T&gt; T getRemoteProxyObj(Class serviceInterface, InetSocketAddress addr) &#123; /*newProxyInstance(a,b,c) * a:类加载器，需要代理哪个类,就需要将哪个类加载器传入第一个参数 * b:需要代理的对象，具备哪些功能(方法) --接口 */ return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class&lt;?&gt;[] &#123;serviceInterface&#125;, new InvocationHandler() &#123; //proxy:代理的对象 method:使用的函数 args:函数的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; //客户端向服务端发送请求：请求某一个具体的接口 Socket socket = new Socket(); //socketaddress: Ip : 端口 socket.connect(addr); output = new ObjectOutputStream( socket.getOutputStream()); //发送:序列化流(对象流) //发送 接口名 方法 参数类型 参数 output.writeUTF(serviceInterface.getName()); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(args); //等待服务端处理 //接受服务端处理后的返回值 input = new ObjectInputStream(socket.getInputStream()); result = input.readObject(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; &#125;) ; &#125; &#125; 服务中心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ServerCenter implements Server&#123; private static HashMap&lt;String, Class&gt; serviceRegiser = new HashMap&lt;&gt;(); private static int port; public ServerCenter() &#123; &#125; public ServerCenter(int port) &#123; this.port = port; &#125; //开启服务 @Override public void start()&#123; ServerSocket server = null; Socket socket = null; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; server = new ServerSocket(); server.bind(new InetSocketAddress(port)); socket = server.accept(); //等待客户端连接 //接受到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); //因为ObjectInputStream对发送数据的顺序严格要求，因此需要按照发送的顺序逐个接受 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[])input.readObject(); Object[] arguments = (Object[])input.readObject(); Class serviceClass = serviceRegiser.get(serviceName); Method method = serviceClass.getMethod(methodName, parameterTypes); Object result = method.invoke(serviceClass.newInstance(), arguments); //将服务端执行完毕的返回值返回给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void stop() &#123; &#125; @Override public void register(Class service, Class serviceImpl) &#123; serviceRegiser.put(service.getName(), serviceImpl); &#125;&#125; 优化 在服务端建立连接池，使服务能够多线程并发执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class ServerCenter implements Server&#123; private static HashMap&lt;String, Class&gt; serviceRegiser = new HashMap&lt;&gt;(); private static int port; private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static boolean isRunning = false; public ServerCenter() &#123; &#125; public ServerCenter(int port) &#123; this.port = port; &#125; //开启服务 @Override public void start()&#123; ServerSocket server = null; try &#123; server = new ServerSocket(); server.bind(new InetSocketAddress(port)); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; Socket socket = null; System.out.println(\"启动服务...\"); isRunning = true; while(true) &#123; try &#123; socket = server.accept(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //等待客户端连接 executor.execute(new ServiceTask(socket)); &#125; &#125; @Override public void stop() &#123; System.out.println(\"关闭服务...\"); isRunning = false; executor.shutdown(); &#125; @Override public void register(Class service, Class serviceImpl) &#123; serviceRegiser.put(service.getName(), serviceImpl); &#125; private static class ServiceTask implements Runnable&#123; Socket socket = new Socket(); public ServiceTask() &#123;&#125; public ServiceTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; //接受到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); //因为ObjectInputStream对发送数据的顺序严格要求，因此需要按照发送的顺序逐个接受 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[])input.readObject(); Object[] arguments = (Object[])input.readObject(); Class serviceClass = serviceRegiser.get(serviceName); Method method = serviceClass.getMethod(methodName, parameterTypes); Object result = method.invoke(serviceClass.newInstance(), arguments); //将服务端执行完毕的返回值返回给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用线程启动服务 1234567891011121314151617public class RPCServerTest &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Server server = new ServerCenter(9999); server.register(HelloService.class, HelloServiceImpl.class); server.start(); &#125; &#125;).start();; &#125;&#125; 客户端测试代码 1234567891011public class RPCClientTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; HelloService service = Client.getRemoteProxyObj(Class.forName(\"com.kexing.rpc.service.HelloService\"), new InetSocketAddress(\"127.0.0.1\", 9999)); System.out.println(service.sayHi(\"zs\")); &#125;&#125; 待优化while(true)","categories":[{"name":"微服务","slug":"微服务","permalink":"https://wlongjie.github.io/categories/微服务/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wlongjie.github.io/tags/Java/"},{"name":"RPC","slug":"RPC","permalink":"https://wlongjie.github.io/tags/RPC/"}]},{"title":"Java反射的简单用法","slug":"Java反射的简单用法","date":"2019-05-30T08:18:22.575Z","updated":"2019-05-30T08:53:13.690Z","comments":true,"path":"2019/05/30/Java反射的简单用法/","link":"","permalink":"https://wlongjie.github.io/2019/05/30/Java反射的简单用法/","excerpt":"","text":"概念 反射机制是在运行状态中： 对于任意一个类，都能够知道这个类的所有属性和方法。 对于任意一个对象，都能够调用它的任意一个方法和属性。 提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的的成员变量和方法 在运行时调用任意一个对象的方法 生成动态代理 获得反射入口的三种方式(获得类)Class.forName(全类名)(推荐使用)123456try &#123; Class&lt;?&gt; classStu = Class.forName(&quot;reflect.Student&quot;); System.out.println(classStu); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 类名.class12Class&lt;?&gt; classStu2 = Student.class;System.out.println(classStu2); 对象.getClass()123Student stu = new Student();Class&lt;?&gt; classStu3 = stu.getClass();System.out.println(classStu3); 通过反射获取类的相关信息获取所有的公共的方法 方法范围是本类以及父类、接口中的所有公有的方法 符合访问修饰的规律 1234Method[] methods = classStu.getMethods(); for(Method method : methods) &#123; System.out.println(method); &#125; 获取该类的所有接口1234Class&lt;?&gt;[] interfaces = classStu.getInterfaces(); for(Class&lt;?&gt; inter : interfaces) &#123; System.out.println(inter); &#125; 获取该类的父类12Class&lt;?&gt; superClass = classStu.getSuperclass(); System.out.println(superClass); 获取该类的所有的构造方法1234Constructor&lt;?&gt;[] constructors = classStu.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; 获取所有公共属性 属性范围是本类以及父类中的所有公有的属性 1234Field[] fields = classStu.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125; 获取当前类的所有方法 包含私有方法(忽略访问修饰符) 不包括父类方法，但包含接口的实现方法 1234Method[] declaredMethods = classStu.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125; 获取当前类的所有属性 包含私有属性 不包含父类属性 1234Field[] declaredFields = classStu.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); &#125; 获取当前反射所代表类(接口)的对象(实例) 相当于new了一个对象 123Object newInstance = classStu.newInstance(); Student stu = (Student)newInstance; stu.breathe(); 通过反射获取对象的实例，并操作对象(实例)操作属性 使用场景：没有set构造器 12345Student stu = (Student)classStu.newInstance(); Field idFieAge = classStu.getDeclaredField(&quot;age&quot;); idFieAge.setAccessible(true);//修改访问权限(private) idFieAge.set(stu, 1);//相当于stu.setAge(1); System.out.println(stu.getAge()); 操作函数 无参私有函数 1234Student stu = (Student)classStu.newInstance(); Method method = classStu.getDeclaredMethod(&quot;sleep&quot;, null);//(函数名，参数) method.setAccessible(true);//private函数 method.invoke(stu, null);//null表示无参数 有参公有函数 123Student stu = (Student)classStu.newInstance(); Method method = classStu.getDeclaredMethod(&quot;habby&quot;, String.class);//参数类型 method.invoke(stu, &quot;篮球&quot;); 注：在反射中,基本类型(int)和基本类型的包装类(Integer)是不同的类型 操作构造函数 可以直接new出一个对象 123Constructor&lt;?&gt; constructor = classStu.getConstructor(null); Student stu = (Student)constructor.newInstance(); System.out.println(stu); 动态加载类名和方法 class.txt 12classname=reflect.Studentmethodname=staticMethod 动态调用 1234567891011121314151617Properties prop = new Properties(); prop.load(new FileReader(&quot;class.txt&quot;)); String classname = prop.getProperty(&quot;classname&quot;); String methodname = prop.getProperty(&quot;methodname&quot;); Class&lt;?&gt; classStu = null; //反射入口 try &#123; classStu = Class.forName(classname); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method method = classStu.getMethod(methodname); method.setAccessible(true); method.invoke(classStu.newInstance()); 通过反射越过泛型检查 在Integer列表中加入String 123456789ArrayList&lt;Integer&gt; list = new ArrayList(); list.add(123); list.add(22); Class&lt;?&gt; classStu = list.getClass(); Method method = classStu.getMethod(&quot;add&quot;, Object.class); method.invoke(list, &quot;ssss&quot;); System.out.println(list); 结果 [123, 22, ssss] 注：虽然可以通过反射访问等访问修饰符不允许访问的属性和方法，也可以忽略掉泛型检查，但不推荐使用，可能会引起程序的混乱 通过反射实现万能set方法 obj：对象 propertyName：属性名 value：属性值 12345678public static void setProperty(Object obj, String propertyName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Class&lt;?&gt; clazz = obj.getClass(); Field field = clazz.getDeclaredField(propertyName); field.setAccessible(true); field.set(obj, value); &#125;","categories":[{"name":"Java基础技术栈","slug":"Java基础技术栈","permalink":"https://wlongjie.github.io/categories/Java基础技术栈/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wlongjie.github.io/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://wlongjie.github.io/tags/反射/"}]},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2019-05-30T08:18:22.572Z","updated":"2019-05-30T08:50:22.385Z","comments":true,"path":"2019/05/30/设计模式之单例模式/","link":"","permalink":"https://wlongjie.github.io/2019/05/30/设计模式之单例模式/","excerpt":"","text":"概念 单例模式是常见的设计模式之一，分为饿汉式和懒汉式。 使用场景：在项目中，频繁使用的全局单一对象。 饿汉式 先创建好单例对象，后使用 优点：写法简单，在类加载时候创建对象，避免了线程同步的问题 缺点：如果后期开发未使用该单例对象，浪费内存 1234567891011121314public class SingleTon &#123; private static SingleTon instance = new SingleTon(); //创建对象的过程可以使用静态代码块代替 // static &#123; // instance = new SingleTon(); // &#125; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; return instance; &#125;&#125; 懒汉式 在第一使用时创建对象(延迟加载) 优点：避免浪费内存 缺点：有可能出现线程不安全的问题(多次创建对象) 线程不安全的1234567891011121314151617181920public class SingleTon &#123; private static SingleTon instance; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; if (null == instance) &#123; /* 此处会出现线程安全问题。 出现原因：线程在内存中是以时间片轮转的方式运行， 可能出现多个线程运行到此处。 */ instance = new SingleTon(); &#125; return instance; &#125; &#125; 同步代码块12345678910111213141516public class SingleTon &#123; private static SingleTon instance; private SingleTon()&#123;&#125; public static SingleTon getInstance() &#123; //此处也会出现线程安全问题，原因同上 //解决方法：双重检查(由于内存中存在线程无序执行,无法实现) if (null == instance) &#123; synchronized (SingleTon.class) &#123; instance = new SingleTon(); &#125; &#125; return instance; &#125;&#125; 同步函数12345678910111213public class SingleTon &#123; private static SingleTon instance; private SingleTon()&#123;&#125; //此种方法可以解决多线程安全问题，但是效率极低(相当于单线程执行) public static synchronized SingleTon getInstance() &#123; if (null == instance) &#123; instance = new SingleTon(); &#125; return instance; &#125;&#125; 利用静态内部类(推荐) 静态内部类在第一次使用的时候进行加载 优点：实现了懒加载的特性，避免了多线程安全问题 1234567891011public class SingleTon &#123; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; return InstanceBuilder.instance; &#125; private static class InstanceBuilder&#123; private static SingleTon instance = new SingleTon(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wlongjie.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wlongjie.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://wlongjie.github.io/tags/单例模式/"}]}]}