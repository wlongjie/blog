<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue学习总结]]></title>
    <url>%2F2019%2F07%2F17%2FVue%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[安装简单安装官网下载网址： https://vuejs.org/js/vue.js https://vuejs.org/js/vue.min.js 其他安装方式：https://cn.vuejs.org/v2/guide/installation.html 注：在网页中引入js文件即可 简单入门**注：1234567891011121314151617181920212223### 网页测试方式在网页（需要引入```vue.js```文件）f12的控制台```console```中编写```js```代码测试网页（查看网页的反馈）### 网页渲染#### 简单字符串数据渲染（响应式绑定）```html&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;//这里注意要放在标签的下面，下面例子类似var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;)可以在console中输入app.message = &apos;改变&apos;测试数据绑定的效果 绑定标签的属性123456789101112131415&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt;var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '页面加载于 ' + new Date().toLocaleString() &#125;&#125;)可以在console中输入app2.message = '改变'，再查看悬停信息测试效果注：此处的v-bind:title可以简写为:title 条件和循环条件1234567891011121314&lt;div id="app-3"&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;)这里seen为true（非初始化数据都行）时标签显示seen为false（false,0,null,undefine等）时标签隐藏（不会占位置）可以在console中输入app3.seen = false测试效果 循环1234567891011121314151617181920&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;)可以在console中输入app4.todos.push(&#123; text: '新项目' &#125;)添加一个别表元素测试效果 事件和表单元素点击事件1234567891011121314151617181920212223&lt;div id="app-5"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt;反转消息&lt;/button&gt;&lt;/div&gt;var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;)可以在console中输入app5.reverseMessage = function()&#123;alert('测试')&#125;修改事件函数再点击测试效果（此处可能有延迟，我是点两次才有效果）split('')将字符串以某分隔符分割（空字符是一个个分割）reverse()将原数据进行翻转（第一个放在最后，第二个放在倒数第二个，类推）join('')将数据以某个分割符（空字符是一个个紧凑拼接）拼接成一个字符串注：此处v-on:click可以简写@click 输入框内容绑定1234567891011121314&lt;div id="app-6"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;)可以在console中输入app6.message = '改了'查看输入框信息测试效果在输入框中输入数据，app6.message的值也会跟着改变 组件简单组件123456789101112131415161718&lt;div id="app"&gt; &lt;ol&gt; //创建一个组件实例 &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;//定义一个组件Vue.component('todo-item', &#123; template: `&lt;li&gt;这是待办项&lt;/li&gt;`&#125;);//必须创建实例var app = new Vue(&#123; el: "#app"&#125;);注：这里Vue.component是定义全局组件 使用参数12345678910111213141516171819202122232425262728&lt;div id="app-7"&gt; &lt;ol&gt; &lt;todo-item v-for="item in groceryList" v-bind:todo="item" v-bind:key="item.id"&gt; &lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;);var app7 = new Vue(&#123; el: "#app-7", data: &#123; groceryList: [ &#123; id: 0, text: '蔬菜' &#125;, &#123; id: 1, text: '奶酪' &#125;, &#123; id: 2, text: '随便' &#125; ] &#125;&#125;);与上一个例子相比：可以利用循环同时生成一系列列表元素可以在console中输入app7.groceryList[0].text = '改了'修改列表数据 组件与自定义元素的关系 你可能已经注意到 组件非常类似于自定义元素——它是 ```Web``` 组件规范的一部分，这是因为 ```Vue``` 的组件语法部分参考了该规范。例如 ```Vue``` 组件实现了 ```Slot API``` 与 ```is``` 特性。但是，还是有几个关键差别：1234567891011121314151617&gt;&gt; ```Web Components``` 规范已经完成并通过，但未被所有浏览器原生实现。目前 ```Safari 10.1+```、```Chrome 54+``` 和 ```Firefox 63+``` 原生支持 ```Web Components```。相比之下，```Vue``` 组件不需要任何 ```polyfill```，并且在所有支持的浏览器 (```IE9``` 及更高版本) 之下表现一致。必要时，```Vue``` 组件也可以包装于原生自定义元素之内。&gt;&gt; ```Vue``` 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。&gt;&gt; 虽然 ```Vue``` 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，依然有很好的互操作性。```Vue CLI``` 也支持将 ```Vue``` 组件构建成为原生的自定义元素。## ```Vue```实例### 创建和相关#### 创建```htmlvar vm = new Vue(&#123; // 选项&#125;) **注：所有的12345678910111213141516171819202122232425262728### 数据和方法#### 数据响应式绑定```html// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;)// 获得这个实例上的属性// 返回源数据中对应的字段vm.a == data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ……反之亦然data.a = 3vm.a // =&gt; 3上面的js代码可以在console中测试只有实例被创建时，data数据才是响应式的 注意定义变量时需要初始化1234567data: &#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 阻止数据响应式绑定12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 `foo` 不会更新！ --&gt; &lt;button v-on:click="foo = 'baz'"&gt;Change it&lt;/button&gt;&lt;/div&gt;var obj = &#123; foo: 'bar'&#125;//禁止obj被响应式绑定Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;)可以去掉Object.freeze(obj)再运行测试效果 实例的属性和方法12345678910111213141516var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;)可以在console中测试效果注：===是判断数据的类型以及值是否相同，（判断类型时会短路） 生命周期钩子1234567891011121314```htmlnew Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log(&apos;a is: &apos; + this.a) &#125;&#125;)// =&gt; &quot;a is: 1&quot;created钩子会在实例被创建后的调用其他钩子12345678beforecreate：可以在这加个loading事件，在加载实例时触发created：初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用beforeMountmounted：挂载元素，获取到DOM节点beforeUpdateupdated：如果对数据统一处理，在这里写上相应的函数beforeDestroy：可以做一个确认停止事件的确认框destroyed 与箭头函数冲突 不要在选项属性或回调上使用箭头函数，比如 () 1234567891011121314151617181920212223242526## 模板语法**注：```&#123;&#123;&#125;&#125;```语法是```Mustache```语法**### 插值#### 文本绑定```html&lt;div id=&quot;app&quot;&gt; //可以随时更新数据 &lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; //只能一次性插值，不能更新，会影响该节点下的其他数据绑定 &lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;Hello Vue!&apos; &#125;&#125;)可以在console中输入app.msg = &apos;改了&apos;测试效果 解析文本中的12345678910111213141516```html&lt;div id=&quot;app-9&quot;&gt; &lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt; //span的内容被替换 &lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;var app9 = new Vue(&#123; el: &apos;#app-9&apos;, data: &#123; rawHtml: &apos;&lt;span style=&quot;color:red&quot;&gt;This should be red.&lt;/span&gt;&apos; &#125;&#125;);使用v-html表可以解析文本中的HTML标签1234567891011121314151617181920212223242526&gt; 你的站点上动态渲染的任意 ```HTML``` 可能会非常危险，因为它很容易导致 ```XSS``` 攻击。请只对可信内容使用 ```HTML``` 插值，绝不要对用户提供的内容使用插值。&gt;&gt; 简言之，尽量不用```v-html```解析文本中的```HTML```标签#### 特性(```v-bind```)**注：```Mustache```语法不能作用在```HTML```特性上，应使用```v-bind```指令**```html&lt;div id=&quot;app-10&quot;&gt; //简单设置属性值 &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; //设置是否可用 &lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;&lt;/div&gt;var app10 = new Vue(&#123; el: &apos;#app-10&apos;, data: &#123; dynamicId: &apos;div_vue&apos;, isButtonDisabled: false &#125;&#125;);注：此处的布尔值不能是undefine（会报错），除了false和null其他都表现为true使用123456789101112```html例：&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;注：只能使用单个表达式 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 ```和``` Date``` 。你不应该在模板表达式中试图访问用户定义的全局变量。12345678910### 指令#### 解释&gt; 指令是带有```v-```前缀的特殊特性&gt;&gt; 指令特性的值预期是单个```JavaScript```表达式（```v-for```例外）&gt;&gt; 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于```DOM 1例:&lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt; 参数 一些指令能够接受一个“参数”，在指令名称之后以冒号表示 1234&lt;a v-bind:href="url"&gt;...&lt;/a&gt;在这里href是参数，告知v-bind指令将元素的href特性与表达式url的值绑定&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt; 动态参数（2.6.0新增）1234&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;这里的attributeName会作为一个JavaScript表达式进行动态求值，求得的值将会作为最终的参数来使用&lt;a v-on:[eventName]="doSomething"&gt; ... &lt;/a&gt; 对动态参数的约束 动态参数预期会求出一个字符串，异常情况下值为123456789101112131415161718&gt;&gt; 这个特殊的```null```值可以被显示地用于移除绑定&gt;&gt; 任何其他非字符串类型的值都将会触发一个警告&gt; 对动态参数表达式的约束&gt;&gt; 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在```HTML```特性名里是无效的&gt;&gt; 同样，在```DOM```中使用模板时也需要回避大写键名```html例：&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:[&apos;foo&apos; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;&lt;!-- 在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]` --&gt;&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt; 修饰符 修饰符（123456789&gt;&gt; 用于指出一个指令应该以特殊方式绑定```html&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()注：event.preventDefault() 阻止默认行为，如a标签的href 缩写(1234567891011```html&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;计算属性使用计算属性的原因 在模板中放入太多的逻辑会让模板过重且难以维护 而且可读性较差 基础例子12345678910111213141516171819202122&lt;div id="example"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt;Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)注：计算属性是带有缓存的如果message的值不变，再次获取会直接获取，不会计算如果message的值改变，计算属性也随之改变 计算属性缓存 方法1234567891011121314```html//下面调用函数的做法和上面例子的结果相同&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;注：虽然结果相同，但是计算属性是带有缓存的如果message的值不变，不在调用方法，直接返回值，效率较方法要高123456789特殊情况computed: &#123; now: function () &#123; return Date.now() &#125;&#125;这个计算属性是不会更新的因为Date.now()不是响应式依赖 计算属性 侦听属性12&gt; 侦听属性：```watch 容易出现滥用的情况 123456789101112131415161718192021222324252627282930313233&lt;div id="demo"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;//下面的侦听属性的方式，重复代码var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;)下面是计算属性的方式var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 计算属性的12345678910111213141516```htmlcomputed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;侦听器作用 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125; &#125;&#125;)&lt;/script&gt; 12### 绑定```HTML Class对象语法 简单使用 123456789101112131415161718&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt;active这个class存在与否取决于isActive的布尔值例.div_red&#123; color: red;&#125;&lt;div id="app-12" v-bind:class="&#123;div_red: isRed&#125;"&gt; 红色&lt;/div&gt;var app12 = new Vue(&#123; el: '#app-12', data: &#123; isRed: false &#125;&#125;); 和普通12 data: { isActive: true, hasError: false} 结果为 可以和普通的class属性共存12- 定义在模板里 data: { classObject: { active: true, ‘text-danger’: false }}12- 使用计算属性 data: { isActive: true, error: null},computed: { classObject: function () { return { active: this.isActive &amp;&amp; !this.error, ‘text-danger’: this.error &amp;&amp; this.error.type === ‘fatal’ } }}1234567891011121314#### 数组语法&gt; 可以把一个数组传给```v-bind:class```，以应用一个```class```列表- 简单使用```html&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 使用三元表达式 1&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt; 数组语法与对象语法混合使用 1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 用在组件上 在一个自定义组件上使用1234567891011121314&gt;&gt; 这个元素上已经存在的类不会被覆盖- 简单使用```htmlVue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;&#125;)&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;结果为:&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt; 带有数据绑定的 1234&lt;my-component v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/my-component&gt;isActive为true时结果为:&lt;p class="foo bar active"&gt;Hi&lt;/p&gt; 绑定内联样式对象语法 123456789101112&gt;&gt; ```CSS```属性名可以用驼峰式（```camelCase```）或短横线分隔（```kebab-case```，记得用引号括起来）来命名- 数据绑定```html&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 对象数据绑定 12345678910&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125;可读性更好一些 数组语法123&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt;v-bind:style的数组语法可以将多个样式对象应用到同一个元素上 自动添加前缀 当12345678910111213&gt;&gt; ```Vue.js```会自动侦测并添加响应的前缀#### 多重值（2.3.0+）&gt; 从2.3.0起你可以为```style```绑定中的属性提供一个包含多个值的数组&gt;&gt; 常用于提供多个带前缀的值```html&lt;div :style=&quot;&#123; display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] &#125;&quot;&gt;&lt;/div&gt;注：这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex 条件渲染12#### ```v-if```和```v-else123456&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;注：v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别 在组件中使用1234567```html&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;12345678910111213141516```html&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt;注：类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后使用1234567891011121314&gt; ```Vue```会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染```html&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt;注：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder 加一个唯一的123456789101112```html&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt;注：&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性 123456&gt; ```v-show```也是通过条件控制标签是否显示&gt;&gt; 不同的是带有```v-show```的元素始终会被渲染并保留在```DOM```中&gt;&gt; ```v-show```只是简单地切换元素的```CSS```属性```display**注：12### ```v-if``` VS ```v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 ```进行切换。123456789101112131415161718192021222324252627282930313233&gt;&gt; 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。### ```v-if```与```v-for```一起使用**注：不推荐同时使用```v-if```和```v-for```**&gt; 当```v-if```与```v-for```一起使用时，```v-for```具有比```v-if```更高的优先级&gt;&gt; 意味着循环几次判断几次## 列表渲染### 使用```v-for```遍历数组- 使用```v-for```简单渲染列表```html&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 使用索引和父作用域的属性 12345678910111213141516171819&lt;ul id="example-2"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;)可以直接使用父作用域的属性可以直接获取到索引 可以使用123```html&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; 在1234567891011121314151617181920- 简单遍历值```html&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; &#125; &#125;&#125;) 遍历属性名和值 123&lt;div v-for="(value, name) in object"&gt; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 获取索引 123&lt;div v-for="(value, name, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; **注：在遍历对象时，会按123456789101112131415### 维护状态&gt; 当 ```Vue``` 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，```Vue``` 将不会移动 ```DOM``` 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 ```Vue 1.x``` 的 `track-by=&quot;$index&quot;`。&gt;&gt; 总结：只维护各个索引位置的值，不会调整顺序&gt; 这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 ```DOM``` 状态 (例如：表单输入值) 的列表渲染输出**。&gt; 为了给 ```Vue``` 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性：```html&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for特别关联。 注：不要使用对象或数组之类的非基本类型值为v-for的key。请使用字符串或数值类型的值。 数组更新检测]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAX解析xml文件]]></title>
    <url>%2F2019%2F06%2F25%2FSAX%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述​ SAX，全称Simple API for XML，是一种以事件驱动的XMl API，是XML解析的一种新的替代方法，解析XML常用的还有DOM解析，PULL解析（Android特有），SAX与DOM不同的是它边扫描边解析，自顶向下依次解析，由于边扫描边解析，所以它解析XML具有速度快，占用内存少的优点，对于Android等CPU资源宝贵的移动平台来说是一个巨大的优势。 SAX的优点 解析速度快 占用内存少 SAX的缺点 解析过程中，只知道当前解析的标签的名字和属性 只能解析，不能修改xml文件 无法随机访问某个标签（自上而下一一解析） SAX解析适用场合 对于CPU资源宝贵的设备，如Android等移动设备 对于只需要解析而无需修改的需求 步骤 获取xml文件输入流 获取SAX解析对象工厂 获取SAX解析对象 获取转化规则Handler 加载文件流和转化规则 解析 代码实现xml文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;students&gt; &lt;student id="1"&gt; &lt;name&gt;张三1&lt;/name&gt; &lt;age&gt;1&lt;/age&gt; &lt;/student&gt; &lt;student id="2"&gt; &lt;name&gt;张三2&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/student&gt; &lt;student id="3"&gt; &lt;name&gt;张三3&lt;/name&gt; &lt;age&gt;3&lt;/age&gt; &lt;/student&gt; &lt;student id="4"&gt; &lt;name&gt;张三4&lt;/name&gt; &lt;age&gt;4&lt;/age&gt; &lt;/student&gt; &lt;student id="5"&gt; &lt;name&gt;张三5&lt;/name&gt; &lt;age&gt;5&lt;/age&gt; &lt;/student&gt;&lt;/students&gt; 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private int studentId; private String studentName; private int studentAge; public int getStudentId() &#123; return studentId; &#125; public void setStudentId(int studentId) &#123; this.studentId = studentId; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getStudentAge() &#123; return studentAge; &#125; public void setStudentAge(int studentAge) &#123; this.studentAge = studentAge; &#125; @Override public String toString() &#123; return "Student [studentAge=" + studentAge + ", studentId=" + studentId + ", studentName=" + studentName + "]"; &#125; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(int studentId, String studentName, int studentAge) &#123; super(); this.studentId = studentId; this.studentName = studentName; this.studentAge = studentAge; &#125;&#125; 解析规则Handler类 startDocument()：开始读取文档时调用 startElement()：读取开始标签时调用 characters()：读取文本时调用 endElement()：读取结束标签时调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StudentHandle extends DefaultHandler &#123; private List&lt;Student&gt; stuList; private Student student = null; private String temp; public List&lt;Student&gt; getStuList() &#123; return stuList; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; if ("name".equals(temp)) &#123; String studentName = new String(ch, start, length); student.setStudentName(studentName); &#125; else if ("age".equals(temp)) &#123; String studentAge = new String(ch, start, length); student.setStudentAge(Integer.parseInt(studentAge)); &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if ("student".equals(qName)) &#123; stuList.add(student); student = null; &#125; temp = null; &#125; @Override public void startDocument() throws SAXException &#123; stuList = new ArrayList&lt;Student&gt;(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if ("student".equals(qName)) &#123; if (null == student) &#123; student = new Student(); &#125; String studentId = attributes.getValue("", "id"); student.setStudentId(Integer.parseInt(studentId)); &#125; else if ("name".equals(qName)) &#123; temp = "name"; &#125; else if ("age".equals(qName)) &#123; temp = "age"; &#125; &#125;&#125; 业务类123456789101112131415161718public static List&lt;Student&gt; ReadXml() throws Exception &#123; //获取xml文件输入流 InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("student.xml"); //获取sax解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); //获取sax解析类 SAXParser saxParser = factory.newSAXParser(); //获取转化规则 StudentHandle studentHandle = new StudentHandle(); //加载文件流和转化规则 saxParser.parse(is, studentHandle); //转化 List&lt;Student&gt; stuList = studentHandle.getStuList(); //返回 return stuList;&#125;]]></content>
      <categories>
        <category>文件操作</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Sax</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven的简单使用]]></title>
    <url>%2F2019%2F06%2F25%2FMaven%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概述 Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。 Maven的作用 Jar包管理 项目构建：对项目进行编译、测试、打包、部署 安装 下载地址：http://maven.apache.org/download.cgi 下载并解压到本地磁盘（目录不能有空格） 配置环境变量（依赖jdk） 配置环境变量 MAVEN_HOME：E:\Maven\apache-maven-3.6.0 Path：;%MAVEN_HOME%\bin 测试：DOS命令：mvn -v eclipse配置Maven Window-&gt;Preferences-&gt;Maven-&gt;Installations 添加Maven根目录：E:\Maven\apache-maven-3.6.0\ 并勾选使用自己安装的Maven Window-&gt;Preferences-&gt;Maven-&gt;User Settings 修改Global Settings：E:\Maven\apache-maven-3.6.0\conf\settings.xml Idea配置Maven 修改单个项目：File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory：E:\Maven\apache-maven-3.6.0\ 修改User settings file：E:\Maven\apache-maven-3.6.0\conf\settings.xml 修改 Local repository：D:\maven\mavenrep 修改所有新建项目：Others Settings-&gt;Settings for New Projects-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory 修改User settings file：E:\Maven\apache-maven-3.6.0\conf\settings.xml 修改 Local repository：D:\maven\mavenrep Setting.xml文件配置 修改本地仓库位置（本地Jar包存放位置） D:/maven/mavenrep 配置阿里镜像库（提高下载Jar包的速度） 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 我的配置文件（去注释） 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;!-- 本地仓库配置 --&gt; &lt;localRepository&gt;D:/maven/mavenrep&lt;/localRepository&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;!-- 阿里镜像库配置 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt;&lt;/settings&gt;]]></content>
      <categories>
        <category>Jar包管理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单的贪吃蛇]]></title>
    <url>%2F2019%2F05%2F30%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import java.awt.Color;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.util.ArrayList;import javax.swing.JFrame;import javax.swing.JPanel;public class SnakePanel extends JPanel implements KeyListener, Runnable&#123; private static final long serialVersionUID = 1L; public static Image background; public static Image cellImage; public static Image foolImage; ArrayList&lt;Cell&gt; snakeList = new ArrayList&lt;Cell&gt;(); private Cell food = new Cell(); //方向 public char direction = Direction.RIGHT; public boolean isLive = true; //速度 public int sleep = 100; //横向35个 //纵向35个 public static final int MIN_X = 50 + 2; public static final int MAX_X = MIN_X + 10 * 35 - 10;//350 - 10 + 2 public static final int MIN_Y = 50 - 2; public static final int MAX_Y = MIN_Y + 10 * 35 - 10;//350 - 10 - 2// public static final int edge = 10; public SnakePanel() &#123; background = Toolkit.getDefaultToolkit().createImage("bg.png"); cellImage = Toolkit.getDefaultToolkit().createImage("cell.png"); foolImage = Toolkit.getDefaultToolkit().createImage("food.png"); //初始化蛇 int x = MIN_X; int y = MIN_Y; for (int i = 0; i &lt; 10; i++) &#123; Cell cell = new Cell(x, y); snakeList.add(cell); x += 10; &#125; //初始化食物 getFood(); &#125; //创建食物 public void getFood() &#123; boolean flag; int x, y; do&#123; flag = false; x = (int)(Math.random() * 35) * 10 + 52; y = (int)(Math.random() * 35) * 10 + 48; for (Cell cell : snakeList) &#123; if (cell.getX() == x &amp;&amp; cell.getY() == y) &#123; flag = true; break; &#125; &#125; &#125;while(flag); food.setX(x); food.setY(y); &#125; @Override public void paint(Graphics g) &#123; super.paint(g); g.drawImage(background, 0, 0, this); //g.draw3DRect(50, 50 - 2, 350, 350 - 2, true); //g.draw3DRect(50, 50 - 2, 10, 10, false); for (Cell cell : snakeList) &#123; g.drawImage(cellImage, cell.x , cell.y, this); &#125; g.drawImage(foolImage, food.x , food.y, this); //g.translate(x, y)：将坐标原点移动到(x,y) if (!isLive)&#123; int x = (MIN_X + MAX_X) / 2; int y = (MIN_Y + MAX_Y) / 2; g.setColor(Color.red); g.drawString("Game over !!!", x, y); //死亡信息 &#125; &#125; public static void main(String[] args) &#123; JFrame frame = new JFrame(); frame.setTitle("小破蛇"); frame.setSize(470, 480); frame.setVisible(true); //设置窗口居中显示 frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); SnakePanel sp = new SnakePanel(); frame.add(sp); //frame.setContentPane(new SnakePanel()); //注册事件监听 frame.addKeyListener(sp); //线程 new Thread(sp).start(); &#125; public class Direction &#123; public static final char UP = 'w'; public static final char DOWN = 's'; public static final char LEFT = 'a'; public static final char RIGHT = 'd'; &#125; public class Cell &#123; private int x; private int y; public Cell() &#123; &#125; public Cell(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; &#125; //键盘控制方向 //按下 @Override public void keyPressed(KeyEvent e) &#123; if(e.getKeyCode() == KeyEvent.VK_W || e.getKeyCode() == KeyEvent.VK_UP) &#123; if(direction != Direction.DOWN)direction = Direction.UP; &#125; else if(e.getKeyCode() == KeyEvent.VK_A || e.getKeyCode() == KeyEvent.VK_LEFT) &#123; if(direction != Direction.RIGHT)direction = Direction.LEFT; &#125; else if(e.getKeyCode() == KeyEvent.VK_S || e.getKeyCode() == KeyEvent.VK_DOWN) &#123; if(direction != Direction.UP)direction = Direction.DOWN; &#125; else if(e.getKeyCode() == KeyEvent.VK_D || e.getKeyCode() == KeyEvent.VK_RIGHT) &#123; if(direction != Direction.LEFT)direction = Direction.RIGHT; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; //按下并释放(敲击) @Override public void keyTyped(KeyEvent e) &#123; &#125; //线程：重画 @Override public void run() &#123; while(true) &#123; try &#123; Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int x = snakeList.get(snakeList.size() - 1).x; int y = snakeList.get(snakeList.size() - 1).y; switch(direction) &#123; case Direction.DOWN: y += 10; break; case Direction.LEFT: x -= 10; break; case Direction.RIGHT: x += 10; break; case Direction.UP: y -= 10; break; &#125; //撞墙 if (x &lt; MIN_X || x &gt; MAX_X || y &lt; MIN_Y || y &gt; MAX_Y) &#123; //提示处理 isLive = false; break; &#125; boolean flag = false; for(Cell cell : snakeList) &#123; if (cell.getX() == x &amp;&amp; cell.getY() == y) &#123; flag = true; break; &#125; &#125; //撞自己 if (flag) &#123; //提示处理 isLive = false; break; &#125; //吃食物 if (x == food.x &amp;&amp; y == food.y) &#123; //添加长度 Cell cell = new Cell(x, y); snakeList.add(cell); //重新生成食物 getFood(); &#125; else &#123; //蛇头前进 Cell cell = new Cell(x, y); snakeList.add(cell); //蛇尾前进 snakeList.remove(0); &#125; this.repaint(); &#125; this.repaint(); &#125; &#125; 图片 bg.png:背景 cell:png：一节蛇 food.png:食物 注意 直接运行会报异常，需要三张图片 请根据自己的图片调整蛇的活动区域]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>贪吃蛇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单的RPC]]></title>
    <url>%2F2019%2F05%2F30%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84RPC%2F</url>
    <content type="text"><![CDATA[RPC解释 RPC：Remote Procedure Call(远程过程调用) 客户端获取服务端的服务(不同的计算机) RPC所需要的技术 反射技术：客户端给服务端发送代表接口名的字符串，服务端需要通过字符串解析出该字符串代表的接口的一切信息 socket：客户端与服务端交互(传输信息) 动态代理：服务端需要根据客户端的不同请求，返回不同的接口类型，客户端需要接受到不同的接口类型 代码实现 客户端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Client &#123; //获取代表服务端接口的动态代理对象 //serviceName:请求的接口名 //addr:待请求服务端的ip:端口 @SuppressWarnings("unchecked") public static &lt;T&gt; T getRemoteProxyObj(Class serviceInterface, InetSocketAddress addr) &#123; /*newProxyInstance(a,b,c) * a:类加载器，需要代理哪个类,就需要将哪个类加载器传入第一个参数 * b:需要代理的对象，具备哪些功能(方法) --接口 */ return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class&lt;?&gt;[] &#123;serviceInterface&#125;, new InvocationHandler() &#123; //proxy:代理的对象 method:使用的函数 args:函数的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; //客户端向服务端发送请求：请求某一个具体的接口 Socket socket = new Socket(); //socketaddress: Ip : 端口 socket.connect(addr); output = new ObjectOutputStream( socket.getOutputStream()); //发送:序列化流(对象流) //发送 接口名 方法 参数类型 参数 output.writeUTF(serviceInterface.getName()); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(args); //等待服务端处理 //接受服务端处理后的返回值 input = new ObjectInputStream(socket.getInputStream()); result = input.readObject(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; &#125;) ; &#125; &#125; 服务中心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ServerCenter implements Server&#123; private static HashMap&lt;String, Class&gt; serviceRegiser = new HashMap&lt;&gt;(); private static int port; public ServerCenter() &#123; &#125; public ServerCenter(int port) &#123; this.port = port; &#125; //开启服务 @Override public void start()&#123; ServerSocket server = null; Socket socket = null; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; server = new ServerSocket(); server.bind(new InetSocketAddress(port)); socket = server.accept(); //等待客户端连接 //接受到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); //因为ObjectInputStream对发送数据的顺序严格要求，因此需要按照发送的顺序逐个接受 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[])input.readObject(); Object[] arguments = (Object[])input.readObject(); Class serviceClass = serviceRegiser.get(serviceName); Method method = serviceClass.getMethod(methodName, parameterTypes); Object result = method.invoke(serviceClass.newInstance(), arguments); //将服务端执行完毕的返回值返回给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void stop() &#123; &#125; @Override public void register(Class service, Class serviceImpl) &#123; serviceRegiser.put(service.getName(), serviceImpl); &#125;&#125; 优化 在服务端建立连接池，使服务能够多线程并发执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class ServerCenter implements Server&#123; private static HashMap&lt;String, Class&gt; serviceRegiser = new HashMap&lt;&gt;(); private static int port; private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static boolean isRunning = false; public ServerCenter() &#123; &#125; public ServerCenter(int port) &#123; this.port = port; &#125; //开启服务 @Override public void start()&#123; ServerSocket server = null; try &#123; server = new ServerSocket(); server.bind(new InetSocketAddress(port)); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; Socket socket = null; System.out.println("启动服务..."); isRunning = true; while(true) &#123; try &#123; socket = server.accept(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //等待客户端连接 executor.execute(new ServiceTask(socket)); &#125; &#125; @Override public void stop() &#123; System.out.println("关闭服务..."); isRunning = false; executor.shutdown(); &#125; @Override public void register(Class service, Class serviceImpl) &#123; serviceRegiser.put(service.getName(), serviceImpl); &#125; private static class ServiceTask implements Runnable&#123; Socket socket = new Socket(); public ServiceTask() &#123;&#125; public ServiceTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; //接受到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); //因为ObjectInputStream对发送数据的顺序严格要求，因此需要按照发送的顺序逐个接受 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[])input.readObject(); Object[] arguments = (Object[])input.readObject(); Class serviceClass = serviceRegiser.get(serviceName); Method method = serviceClass.getMethod(methodName, parameterTypes); Object result = method.invoke(serviceClass.newInstance(), arguments); //将服务端执行完毕的返回值返回给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null != output) &#123; output.close(); &#125; if(null != input) &#123; input.close(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用线程启动服务 1234567891011121314151617public class RPCServerTest &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Server server = new ServerCenter(9999); server.register(HelloService.class, HelloServiceImpl.class); server.start(); &#125; &#125;).start();; &#125;&#125; 客户端测试代码 1234567891011public class RPCClientTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; HelloService service = Client.getRemoteProxyObj(Class.forName("com.kexing.rpc.service.HelloService"), new InetSocketAddress("127.0.0.1", 9999)); System.out.println(service.sayHi("zs")); &#125;&#125; 待优化while(true)]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射的简单用法]]></title>
    <url>%2F2019%2F05%2F30%2FJava%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概念 反射机制是在运行状态中： 对于任意一个类，都能够知道这个类的所有属性和方法。 对于任意一个对象，都能够调用它的任意一个方法和属性。 提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的的成员变量和方法 在运行时调用任意一个对象的方法 生成动态代理 获得反射入口的三种方式(获得类)Class.forName(全类名)(推荐使用)123456try &#123; Class&lt;?&gt; classStu = Class.forName(&quot;reflect.Student&quot;); System.out.println(classStu); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 类名.class12Class&lt;?&gt; classStu2 = Student.class;System.out.println(classStu2); 对象.getClass()123Student stu = new Student();Class&lt;?&gt; classStu3 = stu.getClass();System.out.println(classStu3); 通过反射获取类的相关信息获取所有的公共的方法 方法范围是本类以及父类、接口中的所有公有的方法 符合访问修饰的规律 1234Method[] methods = classStu.getMethods(); for(Method method : methods) &#123; System.out.println(method); &#125; 获取该类的所有接口1234Class&lt;?&gt;[] interfaces = classStu.getInterfaces(); for(Class&lt;?&gt; inter : interfaces) &#123; System.out.println(inter); &#125; 获取该类的父类12Class&lt;?&gt; superClass = classStu.getSuperclass(); System.out.println(superClass); 获取该类的所有的构造方法1234Constructor&lt;?&gt;[] constructors = classStu.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; 获取所有公共属性 属性范围是本类以及父类中的所有公有的属性 1234Field[] fields = classStu.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125; 获取当前类的所有方法 包含私有方法(忽略访问修饰符) 不包括父类方法，但包含接口的实现方法 1234Method[] declaredMethods = classStu.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125; 获取当前类的所有属性 包含私有属性 不包含父类属性 1234Field[] declaredFields = classStu.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); &#125; 获取当前反射所代表类(接口)的对象(实例) 相当于new了一个对象 123Object newInstance = classStu.newInstance(); Student stu = (Student)newInstance; stu.breathe(); 通过反射获取对象的实例，并操作对象(实例)操作属性 使用场景：没有set构造器 12345Student stu = (Student)classStu.newInstance(); Field idFieAge = classStu.getDeclaredField(&quot;age&quot;); idFieAge.setAccessible(true);//修改访问权限(private) idFieAge.set(stu, 1);//相当于stu.setAge(1); System.out.println(stu.getAge()); 操作函数 无参私有函数 1234Student stu = (Student)classStu.newInstance(); Method method = classStu.getDeclaredMethod(&quot;sleep&quot;, null);//(函数名，参数) method.setAccessible(true);//private函数 method.invoke(stu, null);//null表示无参数 有参公有函数 123Student stu = (Student)classStu.newInstance(); Method method = classStu.getDeclaredMethod(&quot;habby&quot;, String.class);//参数类型 method.invoke(stu, &quot;篮球&quot;); 注：在反射中,基本类型(int)和基本类型的包装类(Integer)是不同的类型 操作构造函数 可以直接new出一个对象 123Constructor&lt;?&gt; constructor = classStu.getConstructor(null); Student stu = (Student)constructor.newInstance(); System.out.println(stu); 动态加载类名和方法 class.txt 12classname=reflect.Studentmethodname=staticMethod 动态调用 1234567891011121314151617Properties prop = new Properties(); prop.load(new FileReader(&quot;class.txt&quot;)); String classname = prop.getProperty(&quot;classname&quot;); String methodname = prop.getProperty(&quot;methodname&quot;); Class&lt;?&gt; classStu = null; //反射入口 try &#123; classStu = Class.forName(classname); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method method = classStu.getMethod(methodname); method.setAccessible(true); method.invoke(classStu.newInstance()); 通过反射越过泛型检查 在Integer列表中加入String 123456789ArrayList&lt;Integer&gt; list = new ArrayList(); list.add(123); list.add(22); Class&lt;?&gt; classStu = list.getClass(); Method method = classStu.getMethod(&quot;add&quot;, Object.class); method.invoke(list, &quot;ssss&quot;); System.out.println(list); 结果 [123, 22, ssss] 注：虽然可以通过反射访问等访问修饰符不允许访问的属性和方法，也可以忽略掉泛型检查，但不推荐使用，可能会引起程序的混乱 通过反射实现万能set方法 obj：对象 propertyName：属性名 value：属性值 12345678public static void setProperty(Object obj, String propertyName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Class&lt;?&gt; clazz = obj.getClass(); Field field = clazz.getDeclaredField(propertyName); field.setAccessible(true); field.set(obj, value); &#125;]]></content>
      <categories>
        <category>Java基础技术栈</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F05%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 单例模式是常见的设计模式之一，分为饿汉式和懒汉式。 使用场景：在项目中，频繁使用的全局单一对象。 饿汉式 先创建好单例对象，后使用 优点：写法简单，在类加载时候创建对象，避免了线程同步的问题 缺点：如果后期开发未使用该单例对象，浪费内存 1234567891011121314public class SingleTon &#123; private static SingleTon instance = new SingleTon(); //创建对象的过程可以使用静态代码块代替 // static &#123; // instance = new SingleTon(); // &#125; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; return instance; &#125;&#125; 懒汉式 在第一使用时创建对象(延迟加载) 优点：避免浪费内存 缺点：有可能出现线程不安全的问题(多次创建对象) 线程不安全的1234567891011121314151617181920public class SingleTon &#123; private static SingleTon instance; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; if (null == instance) &#123; /* 此处会出现线程安全问题。 出现原因：线程在内存中是以时间片轮转的方式运行， 可能出现多个线程运行到此处。 */ instance = new SingleTon(); &#125; return instance; &#125; &#125; 同步代码块12345678910111213141516public class SingleTon &#123; private static SingleTon instance; private SingleTon()&#123;&#125; public static SingleTon getInstance() &#123; //此处也会出现线程安全问题，原因同上 //解决方法：双重检查(由于内存中存在线程无序执行,无法实现) if (null == instance) &#123; synchronized (SingleTon.class) &#123; instance = new SingleTon(); &#125; &#125; return instance; &#125;&#125; 同步函数12345678910111213public class SingleTon &#123; private static SingleTon instance; private SingleTon()&#123;&#125; //此种方法可以解决多线程安全问题，但是效率极低(相当于单线程执行) public static synchronized SingleTon getInstance() &#123; if (null == instance) &#123; instance = new SingleTon(); &#125; return instance; &#125;&#125; 利用静态内部类(推荐) 静态内部类在第一次使用的时候进行加载 优点：实现了懒加载的特性，避免了多线程安全问题 1234567891011public class SingleTon &#123; private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; return InstanceBuilder.instance; &#125; private static class InstanceBuilder&#123; private static SingleTon instance = new SingleTon(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
</search>
